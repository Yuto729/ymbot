# Cron vs Heartbeat: スケジューリング戦略

## 概要

MoltbotはHeartbeatとCronの2つのスケジューリング機構を提供します。それぞれ異なる目的に最適化されています。

## クイックガイド

| ユースケース | 推奨 | 理由 |
|--------------|------|------|
| 30分ごとにメールチェック | **Heartbeat** | 他のチェックと一緒にバッチ、コンテキスト認識 |
| 毎朝9時ぴったりにレポート送信 | **Cron (isolated)** | 正確なタイミングが必要 |
| カレンダーの今後のイベント監視 | **Heartbeat** | 定期的な意識に自然にフィット |
| 週次の深い分析 | **Cron (isolated)** | スタンドアロンタスク、別モデル使用可能 |
| 20分後にリマインド | **Cron (main, --at)** | ワンショット、正確なタイミング |
| バックグラウンドプロジェクトヘルスチェック | **Heartbeat** | 既存サイクルに乗っかる |

## Heartbeat: 定期的な監視

### 特徴

```
┌────────────────────────────────────┐
│      Heartbeat の性質              │
├────────────────────────────────────┤
│ 実行タイミング: 定期的（30分ごと）  │
│ セッション:     メインセッション    │
│ コンテキスト:   フルコンテキスト    │
│ 目的:          監視と通知          │
│ バッチング:     複数チェックを統合  │
└────────────────────────────────────┘
```

### 適している場合

1. **複数の定期チェック**
   - メール、カレンダー、タスク、天気を1回のターンでまとめる
   - 5個のCronジョブの代わりに1個のHeartbeat

2. **コンテキスト認識が必要**
   - メインセッションのコンテキストを使って判断
   - 最近の会話を踏まえた通知

3. **会話の連続性**
   - 同じセッションで実行 → 自然な会話フロー
   - フォローアップが容易

4. **低オーバーヘッド監視**
   - 多数の小さなチェックを1回にまとめる
   - API呼び出し削減

### メリット

- ✅ **バッチング**: 1回のターンで複数チェック
- ✅ **コスト削減**: 5個のCronより1個のHeartbeatが安い
- ✅ **コンテキスト**: メインセッションの情報を活用
- ✅ **スマート抑制**: `HEARTBEAT_OK` で不要な通知をスキップ
- ✅ **自然なタイミング**: 若干のドリフトはOK

### デメリット

- ❌ **タイミング不正確**: ±数分のドリフトあり
- ❌ **セッション依存**: メインセッションの状態に影響される
- ❌ **軽量処理のみ**: 重いタスクには不向き

### 設定例

```json5
{
  agents: {
    defaults: {
      heartbeat: {
        every: "30m",
        target: "last",
        activeHours: { start: "08:00", end: "22:00" }
      }
    }
  }
}
```

```md
# HEARTBEAT.md

- Gmail未読チェック（緊急のみ）
- カレンダー確認（次2時間）
- タスクリスト確認（期限が今日）
- 長時間アイドルなら軽くチェックイン
```

## Cron: 正確なスケジューリング

### 特徴

```
┌────────────────────────────────────┐
│       Cron の性質                  │
├────────────────────────────────────┤
│ 実行タイミング: 正確な時刻          │
│ セッション:     main または isolated│
│ コンテキスト:   設定可能            │
│ 目的:          タスク実行          │
│ 独立性:        スタンドアロン可能   │
└────────────────────────────────────┘
```

### 適している場合

1. **正確なタイミング**
   - 「毎朝9:00に」など、時刻指定が必要
   - スケジュール通りの実行が重要

2. **スタンドアロンタスク**
   - 会話コンテキスト不要
   - 独立した処理単位

3. **異なるモデル/思考レベル**
   - 重い分析にはOpus
   - 軽いタスクにはHaiku

4. **ワンショットリマインダー**
   - 「20分後に」など、一度だけ実行
   - `--at` フラグで時刻指定

5. **ノイズの多いタスク**
   - メインセッション履歴を汚したくない
   - 隔離セッションで実行

6. **外部トリガー**
   - エージェントの状態に関係なく実行
   - 確実な実行が必要

### メリット

- ✅ **正確なタイミング**: 5フィールドcron式 + タイムゾーン
- ✅ **セッション隔離**: `cron:<jobId>` で独立実行
- ✅ **モデル選択**: ジョブごとに最適なモデル
- ✅ **配信制御**: 直接チャネルに配信可能
- ✅ **独立性**: メインセッションの状態に依存しない
- ✅ **ワンショット**: `--at` で未来の時刻指定

### デメリット

- ❌ **コンテキストなし** (isolated): 会話履歴が利用できない
- ❌ **個別実行コスト**: 各ジョブがフルターン
- ❌ **設定が複雑**: Heartbeatより設定項目が多い

### Cron (isolated) 例

```bash
# 毎朝7時にブリーフィング
clawdbot cron add \
  --name "Morning briefing" \
  --cron "0 7 * * *" \
  --tz "America/New_York" \
  --session isolated \
  --message "今日のブリーフィング生成：天気、カレンダー、トップメール、ニュース" \
  --model opus \
  --deliver \
  --channel whatsapp \
  --to "+15551234567"
```

### Cron (main) 例

```bash
# プロジェクトチェック（メインセッションにイベント追加）
clawdbot cron add \
  --name "Project check" \
  --every "4h" \
  --session main \
  --system-event "プロジェクトヘルスチェックの時間です" \
  --wake now
```

### ワンショットリマインダー

```bash
# 20分後にリマインド
clawdbot cron add \
  --name "Meeting reminder" \
  --at "20m" \
  --session main \
  --system-event "ミーティングが10分後に始まります" \
  --wake now \
  --delete-after-run
```

## 決定フローチャート

```
正確な時刻に実行する必要がある？
  YES → Cron
  NO  → 次へ...

メインセッションから隔離が必要？
  YES → Cron (isolated)
  NO  → 次へ...

他の定期チェックとバッチできる？
  YES → Heartbeat（HEARTBEAT.mdに追加）
  NO  → Cron

ワンショットリマインダー？
  YES → Cron with --at
  NO  → 次へ...

異なるモデルや思考レベルが必要？
  YES → Cron (isolated) with --model/--thinking
  NO  → Heartbeat
```

## メインセッション vs 隔離セッション

| | Heartbeat | Cron (main) | Cron (isolated) |
|---|---|---|---|
| **セッション** | Main | Main (via system event) | `cron:<jobId>` |
| **履歴** | 共有 | 共有 | 毎回フレッシュ |
| **コンテキスト** | フル | フル | なし（クリーン） |
| **モデル** | メインセッションのモデル | メインセッションのモデル | オーバーライド可能 |
| **出力** | `HEARTBEAT_OK` 以外を配信 | Heartbeatプロンプト + イベント | 要約をメインに投稿 |

### いつメインセッションCronを使うか

```bash
# メインセッションにイベントを追加したい場合
clawdbot cron add \
  --name "Check project" \
  --every "4h" \
  --session main \
  --system-event "プロジェクトヘルスチェックの時間です" \
  --wake now
```

**用途**:
- 次のHeartbeatで処理してほしい
- フルコンテキストが必要
- 隔離実行は不要

### いつ隔離Cronを使うか

```bash
# クリーンな状態で実行したい場合
clawdbot cron add \
  --name "Deep analysis" \
  --cron "0 6 * * 0" \
  --session isolated \
  --message "週次コードベース分析..." \
  --model opus \
  --thinking high \
  --deliver
```

**用途**:
- クリーンスレート（過去のコンテキスト不要）
- 異なるモデル・設定
- 直接チャネルに配信
- メインセッション履歴を汚さない

## 効率的な組み合わせ

### 推奨パターン

```
Heartbeat（30分ごと）
  - メール監視
  - カレンダー監視
  - タスク監視
  - 軽いチェックイン
  → 1回のAPI呼び出しでバッチ処理

Cron（正確なタイミング）
  - 毎朝7時: ブリーフィング生成
  - 毎週月曜9時: プロジェクトレビュー
  - 随時: ワンショットリマインダー
  → 個別のAPI呼び出し
```

### 実例

**HEARTBEAT.md**（30分ごとチェック）:

```md
# Heartbeat checklist

- Gmail未読チェック（緊急のみ）
- カレンダー確認（次2時間）
- タスクリスト確認（期限が今日）
- 8時間以上静かなら軽くチェックイン
```

**Cronジョブ**（正確なタイミング）:

```bash
# 毎朝7時にブリーフィング
clawdbot cron add \
  --name "Morning brief" \
  --cron "0 7 * * *" \
  --session isolated \
  --message "今日のブリーフィング：天気、カレンダー、トップメール" \
  --deliver

# 毎週月曜9時にプロジェクトレビュー
clawdbot cron add \
  --name "Weekly review" \
  --cron "0 9 * * 1" \
  --session isolated \
  --message "週次プロジェクトレビュー..." \
  --model opus

# ワンショットリマインダー
clawdbot cron add \
  --name "Call back" \
  --at "2h" \
  --session main \
  --system-event "クライアントに折り返し電話" \
  --wake now \
  --delete-after-run
```

## コスト比較

| メカニズム | コストプロファイル |
|------------|-------------------|
| **Heartbeat** | N分ごとに1ターン；HEARTBEAT.mdサイズでスケール |
| **Cron (main)** | 次のHeartbeatにイベント追加（隔離ターンなし） |
| **Cron (isolated)** | ジョブごとに完全なエージェントターン；安いモデル使用可 |

### コスト最適化のヒント

```
1. HEARTBEAT.mdを小さく保つ
   → トークンオーバーヘッド削減

2. 類似チェックをHeartbeatにバッチ
   → 複数Cronの代わりに1個のHeartbeat
   → API呼び出し 80%削減

3. Heartbeatで `target: "none"`
   → 内部処理のみ（メッセージ配信なし）

4. Cronで安いモデル使用
   → 軽量タスクにはHaiku
```

### コスト比較例

```
❌ 非効率な設定:
  Cron: メールチェック（30分ごと）
  Cron: カレンダーチェック（30分ごと）
  Cron: タスクチェック（30分ごと）
  Cron: 天気チェック（30分ごと）
  Cron: ニュースチェック（30分ごと）
  → 5ジョブ × 48回/日 = 240 API呼び出し/日

✅ 効率的な設定:
  Heartbeat: 全チェック統合（30分ごと）
  → 1ジョブ × 48回/日 = 48 API呼び出し/日
  → 80%削減！

  Cron: 朝のブリーフィング（1回/日）
  Cron: 週次レビュー（1回/週）
  → 正確なタイミングが必要なもののみ
```

## Lobster: ワークフロー実行

### いつLobsterを使うか

Lobsterは**多段階ツールパイプライン**で承認が必要な場合に使用。

```
Heartbeat/Cron: いつ実行するか
Lobster:        何を実行するか（多段階）
```

**適用場面**:
- 複数ステップの自動化
- 承認ゲート
- 再開可能なワークフロー

### 組み合わせ例

```bash
# Cronでワークフロートリガー
clawdbot cron add \
  --name "Email workflow" \
  --cron "0 9 * * *" \
  --session isolated \
  --message "Lobsterでメール自動化ワークフローを実行" \
  --deliver
```

Lobsterワークフロー:

```yaml
workflow:
  - step: check_email
    tool: gmail_search
  - step: categorize
    approval: required  # 承認待ち
  - step: draft_replies
    tool: gmail_compose
  - step: send
    approval: required  # 承認待ち
```

## まとめ

```
★ 使い分けの原則

Heartbeat:
  - 定期的な監視と通知
  - 複数チェックのバッチング
  - コンテキスト認識が必要
  → API呼び出し削減、コスト最適化

Cron:
  - 正確なタイミング
  - スタンドアロンタスク
  - 異なるモデル/設定
  → 精密な制御、柔軟性

Lobster:
  - 多段階ワークフロー
  - 承認が必要
  - 再開可能な処理
  → 複雑な自動化
```

**黄金律**: 軽量で頻繁なチェックはHeartbeat、重要で正確なタスクはCron

## 次のステップ

- [Heartbeat機能](./heartbeat.md) - Heartbeatの詳細
- [raspi_todo_appへの適用](../raspi-application.md) - 実装例
